use super::shell;
use super::CORG_VERSION;
use chrono::prelude::*;
use pulldown_cmark::{Event, Options, Parser, Tag};
use std::fs::File;
use std::io;
use std::io::{Error, Write};
use std::path::Path;
use std::process::{Child, Command};

pub struct CorgFile {
    pub contents: String,
    pub file_name: String,
    pub source: String,
}

const SHELL_LOGGER_FILE_NAME: &'static str = "corg-logger.sh";
const CORG_LOGGER_SHELL_SCRIPT: &'static [u8] = include_bytes!("../static/scripts/corg-logger.sh");

impl CorgFile {
    pub fn new(file_name_str: &str, source: &str) -> Self {
        let file_name = String::from(file_name_str);
        let source = String::from(source);
        // First line of the file containing the zsh directive
        let contents = String::from("#!/bin/zsh\n");
        // Create a new mutable instance of CorgFile
        let mut corg_file = Self {
            contents,
            file_name,
            source,
        };

        // Mark Corg version info
        corg_file.push_version_info();

        // Generated filename
        corg_file.push_file_name(file_name_str);

        // Note the date generated
        let current_time = Utc::now().to_rfc3339();
        corg_file.push_timestamp(current_time);

        // Push the start of the script (mostly the logging utility)
        corg_file.push_script_start();

        corg_file
    }

    pub fn push_corgdown(&mut self) {
        if !self.source.is_empty() {
            let mut file_body = String::new();
            let parser = Parser::new_ext(&self.source, Options::empty()).filter(
                |event| match event {
                    Event::Start(Tag::Image(..)) | Event::End(Tag::Image(..)) => false,
                    _ => true,
                },
            );

            shell::push_shell(&mut file_body, parser);
            self.push_body(&file_body);
        }
    }

    pub fn write_file(&mut self) -> io::Result<()> {
        match File::create(&self.file_name) {
            Ok(mut file_handler) => {
                let output = self.to_string();
                file_handler.write_all(output.as_bytes())
            }
            Err(e) => Err(e),
        }
    }

    pub fn push_inline(&mut self, line: &str) {
        self.contents.push_str(line)
    }

    pub fn push_with_newline(&mut self, line: &str) {
        self.contents.push_str("\n");
        self.push(line)
    }

    pub fn push(&mut self, line: &str) {
        self.contents.push_str(line);
        self.contents.push_str("\n");
    }

    pub fn push_body(&mut self, body: &str) {
        self.push_with_newline("# - start doc:");
        // Add the body
        self.push(body);
    }

    pub fn to_string(&self) -> String {
        self.contents.clone()
    }

    fn push_file_name(&mut self, file_name: &str) {
        self.push_inline("# filename: ");
        self.push(file_name);
    }

    fn push_version_info(&mut self) {
        let version_info = format!("# -- GENERATED BY CORG v{} --\n", CORG_VERSION);
        self.push(&version_info)
    }

    fn push_timestamp(&mut self, timestamp: String) {
        self.push_inline("# date: ");
        self.push(&timestamp);
    }

    fn push_script_start(&mut self) {
        // Mark the header
        self.push_with_newline("# - corg head:");
        // Halt execution immediately for non-zero return status
        self.push("set -e");
        // Require utils (mostly for logging and pretty output)
        self.push_with_newline("# - corg utils");
        self.push("source ./utils/corg-logger.sh");
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new() {
        let file_name = "yolo.md";
        let corg_file = CorgFile::new(&file_name, "");
        let directive = "#!/bin/zsh\n";
        let file_name_heading = "# filename:";
        let timestamp_heading = "# date: ";
        let version_info = format!("# -- GENERATED BY CORG v{} --\n", CORG_VERSION);

        assert_eq!(corg_file.file_name, file_name.to_string());
        assert!(corg_file.contents.contains(directive));
        assert!(corg_file.contents.contains(file_name_heading));
        assert!(corg_file.contents.contains(file_name));
        assert!(corg_file.contents.contains(&version_info));
        assert!(corg_file.contents.contains(timestamp_heading));
    }
}
